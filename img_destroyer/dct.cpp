#include "dct.hpp"

constexpr std::array<std::array<double, 8>, 8> dctMatrix = {{
    { 0.353553, 0.353553, 0.353553, 0.353553, 0.353553, 0.353553, 0.353553, 0.353553 },
    { 0.490393, 0.415735, 0.277785, 0.097545, -0.097545, -0.277785, -0.415735, -0.490393 },
    { 0.461940, 0.191342, -0.191342, -0.461940, -0.461940, -0.191342, 0.191342, 0.461940 },
    { 0.415735, -0.097545, -0.490393, -0.277785, 0.277785, 0.490393, 0.097545, -0.415735 },
    { 0.353553, -0.353553, -0.353553, 0.353553, 0.353553, -0.353553, -0.353553, 0.353553 },
    { 0.277785, -0.490393, 0.097545, 0.415735, -0.415735, -0.097545, 0.490393, -0.277785 },
    { 0.191342, -0.461940, 0.461940, -0.191342, -0.191342, 0.461940, -0.461940, 0.191342 },
    { 0.097545, -0.277785, 0.415735, -0.490393, 0.490393, -0.415735, 0.277785, -0.097545 }
}};

constexpr std::array<std::array<double, 8>, 8> dctMatrixT = {{
    { 0.353553, 0.490393, 0.461940, 0.415735, 0.353553, 0.277785, 0.191342, 0.097545 },
    { 0.353553, 0.415735, 0.191342, -0.097545, -0.353553, -0.490393, -0.461940, -0.277785 },
    { 0.353553, 0.277785, -0.191342, -0.490393, -0.353553, 0.097545, 0.461940, 0.415735 },
    { 0.353553, 0.097545, -0.461940, -0.277785, 0.353553, 0.415735, -0.191342, -0.490393 },
    { 0.353553, -0.097545, -0.461940, 0.277785, 0.353553, -0.415735, -0.191342, 0.490393 },
    { 0.353553, -0.277785, -0.191342, 0.490393, -0.353553, -0.097545, 0.461940, -0.415735 },
    { 0.353553, -0.415735, 0.191342, 0.097545, -0.353553, 0.490393, -0.461940, 0.277785 },
    { 0.353553, -0.490393, 0.461940, -0.415735, 0.353553, -0.277785, 0.191342, -0.097545 }
}};

// Умножение матриц 8x8
static Block8x8<double> multiply(const Block8x8<double>& a, const Block8x8<double>& b) {
    Block8x8<double> result{};
    for (int i = 0; i < 8; ++i) {
        for (int j = 0; j < 8; ++j) {
            double sum = 0.0;
            for (int k = 0; k < 8; ++k) {
                sum += a[i][k] * b[k][j];
            }
            result[i][j] = sum;
        }
    }
    return result;
}

// Прямое DCT: C * block * C^T
void DCT::forwardDCT(Block8x8<double>& block) {
    Block8x8<double> temp = multiply(block, dctMatrix);
    block = multiply(dctMatrix, temp);
}

// Обратное DCT: C^T * block * C
void DCT::inverseDCT(Block8x8<double>& block) {
    Block8x8<double> temp = multiply(block, dctMatrixT);
    block = multiply(dctMatrixT, temp);
}